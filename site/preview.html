<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HTML Previewer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=JetBrains+Mono:wght@400;500&display=swap"
    rel="stylesheet">
  <style>
    :root {
      --bg-color: #ffffff;
      --text-color: #000000;
      --accent-color: #000000;
      /* Default */
      --accent-color-rgb: 0, 0, 0;
      /* Default RGB for transparency */
      --on-accent-color: #ffffff;
      /* Contrast text color */
      --secondary-bg: #f4f4f4;
      --border-color: var(--accent-color);
      /* Bind border to accent */
      --border-width: 2px;
      --spacing-unit: 1.5rem;
      --radius: 0px;
    }

    body {
      font-family: 'Inter', sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      margin: 0;
      padding: 0;
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
    }

    .layout {
      max-width: 900px;
      margin: 0 auto;
      padding: var(--spacing-unit);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Header */
    header {
      margin-bottom: var(--spacing-unit);
      border-bottom: var(--border-width) solid var(--border-color);
      padding-bottom: var(--spacing-unit);
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
    }

    h1 {
      font-size: 3rem;
      font-weight: 800;
      margin: 0;
      letter-spacing: -0.05em;
      line-height: 1;
      text-transform: uppercase;
      color: var(--accent-color);
    }

    .subtitle {
      font-size: 1rem;
      font-weight: 500;
      text-transform: uppercase;
      opacity: 0.8;
      margin-top: 0.5rem;
      color: var(--accent-color);
    }

    /* Toolbar */
    .toolbar {
      display: flex;
      gap: 1rem;
      margin-bottom: var(--spacing-unit);
      flex-wrap: wrap;
      position: sticky;
      top: 0;
      background: var(--bg-color);
      padding: 1rem 0;
      z-index: 10;
      border-bottom: 1px solid transparent;
      transition: border-color 0.2s;
    }

    .toolbar.is-stuck {
      border-bottom-color: var(--border-color);
    }

    button {
      background: transparent;
      border: var(--border-width) solid var(--accent-color);
      color: var(--accent-color);
      padding: 0.75rem 1.5rem;
      font-family: 'Inter', sans-serif;
      font-weight: 700;
      font-size: 0.875rem;
      text-transform: uppercase;
      cursor: pointer;
      transition: all 0.15s ease;
      border-radius: var(--radius);
    }

    button:hover {
      background: var(--accent-color);
      color: var(--on-accent-color);
      transform: translateY(-2px);
      box-shadow: 2px 2px 0px rgba(var(--accent-color-rgb), 0.3);
    }

    button:active {
      transform: translateY(0);
      box-shadow: none;
    }

    button.primary {
      background: var(--accent-color);
      color: var(--on-accent-color);
    }

    button.primary:hover {
      opacity: 0.9;
      box-shadow: 2px 2px 0px rgba(var(--accent-color-rgb), 0.5);
    }

    button.danger {
      border-color: var(--danger-color);
      color: var(--danger-color);
    }

    button.danger:hover {
      background: var(--danger-color);
      color: white;
    }

    /* Editor */
    .editor-container {
      position: relative;
      margin-bottom: calc(var(--spacing-unit) * 2);
    }

    textarea {
      width: 100%;
      height: 400px;
      padding: 1.5rem;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
      line-height: 1.6;
      border: var(--border-width) solid var(--border-color);
      border-radius: var(--radius);
      background: var(--secondary-bg);
      resize: vertical;
      outline: none;
      box-sizing: border-box;
      transition: box-shadow 0.2s;
    }

    textarea:focus {
      box-shadow: 4px 4px 0px rgba(var(--accent-color-rgb), 0.2);
      border-color: var(--accent-color);
      background: #fff;
    }

    /* History */
    .history-section {
      border-top: var(--border-width) solid var(--border-color);
      padding-top: var(--spacing-unit);
    }

    .history-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--spacing-unit);
    }

    .history-controls {
      display: flex;
      gap: 0.5rem;
    }

    h2 {
      font-size: 1.5rem;
      font-weight: 800;
      margin: 0;
      text-transform: uppercase;
      letter-spacing: -0.02em;
      color: var(--accent-color);
    }

    .history-list {
      display: grid;
      gap: 1rem;
    }

    .history-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
      border: 1px solid #ddd;
      background: #fff;
      transition: all 0.2s;
    }

    .history-item:hover {
      border-color: var(--accent-color);
      box-shadow: 2px 2px 0px rgba(var(--accent-color-rgb), 0.1);
      transform: translateX(4px);
    }

    .history-info {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8rem;
      color: #555;
    }

    .history-meta {
      font-weight: 600;
      margin-right: 0.5rem;
      color: #000;
    }

    .history-actions {
      display: flex;
      gap: 0.5rem;
      opacity: 0.5;
      transition: opacity 0.2s;
    }

    .history-item:hover .history-actions {
      opacity: 1;
    }

    .btn-icon {
      padding: 0.4rem 0.6rem;
      font-size: 0.75rem;
      border-width: 1px;
    }

    /* Utilities */
    .hidden {
      display: none;
    }

    /* Theme Picker */
    .theme-picker {
      position: relative;
      margin-bottom: 0.5rem;
      height: 2rem;
      /* Fixed height for stability */
      display: flex;
      align-items: center;
      justify-content: flex-end;
    }

    .current-theme {
      width: 2rem;
      height: 2rem;
      background-color: var(--accent-color);
      border: 2px solid var(--border-color);
      cursor: pointer;
      transition: transform 0.2s;
      z-index: 101;
      /* Above dropdown initially */
      position: relative;
    }

    .theme-picker:hover .current-theme {
      transform: scale(0.8);
      /* Shrink slightly to indicate active */
      opacity: 0;
      /* Hide trigger to show dropdown "morphing" from it */
      pointer-events: none;
    }

    .theme-dropdown {
      position: absolute;
      top: 0;
      right: 0;
      height: 2rem;
      background: #fff;
      border: 2px solid var(--border-color);
      display: flex;
      flex-direction: row-reverse;
      /* Expand to left */
      align-items: center;
      gap: 0;
      padding: 0;
      opacity: 0;
      pointer-events: none;
      transform-origin: right center;
      transform: scaleX(0.5);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 100;
      overflow: hidden;
      width: 2rem;
      /* Start width same as trigger */
      box-shadow: none;
    }

    .theme-picker:hover .theme-dropdown {
      opacity: 1;
      pointer-events: auto;
      transform: scaleX(1);
      width: auto;
      /* Allow expansion */
      padding: 2px;
      box-shadow: 4px 4px 0px rgba(var(--accent-color-rgb), 0.2);
      min-width: 300px;
      /* Ensure enough space */
    }

    .theme-option {
      width: 1.5rem;
      height: 1.5rem;
      cursor: pointer;
      border: 1px solid rgba(0, 0, 0, 0.1);
      flex-shrink: 0;
      margin: 0 2px;
    }

    .theme-option:hover {
      transform: scale(1.2);
      z-index: 1;
      border-color: #000;
    }

    @media (max-width: 600px) {
      h1 {
        font-size: 2rem;
      }

      .layout {
        padding: 1rem;
      }

      .toolbar {
        gap: 0.5rem;
      }

      button {
        padding: 0.6rem 1rem;
        font-size: 0.8rem;
        flex: 1;
      }
    }
  </style>
</head>

<body>
  <div class="layout">
    <header>
      <div>
        <h1>Previewer</h1>
        <div class="subtitle">Local HTML Viewer</div>
      </div>
      <div class="theme-picker">
        <div class="current-theme" id="currentThemeIndicator" title="Pick a theme"></div>
        <div class="theme-dropdown" id="themeDropdown">
          <!-- Colors injected by JS -->
        </div>
      </div>
    </header>

    <div class="toolbar" id="toolbar">
      <input type="file" id="fileInput" accept=".html" class="hidden">
      <button id="loadButton">Load File</button>
      <button id="pasteButton">Paste</button>
      <button id="clearButton">Clear</button>
      <button id="viewButton" class="primary">View Result</button>
    </div>

    <div class="editor-container">
      <textarea id="sourceArea" placeholder="<!-- Paste your HTML here -->"></textarea>
    </div>

    <div class="history-section">
      <div class="history-header">
        <h2>History</h2>
        <div class="history-controls">
          <button id="exportHistoryButton">Export</button>
          <button id="importHistoryButton">Import</button>
          <button id="clearHistoryButton" class="danger">Reset</button>
        </div>
        <input type="file" id="importHistoryInput" accept=".json" class="hidden">
      </div>
      <div id="historyList" class="history-list" aria-live="polite"></div>
    </div>
  </div>

  <script>
    // @ts-check
    /** @typedef {{ id?: number, ts: number, content: string, note?: string }} HistoryEntry */

    // Elements
    /** @type {{
     *  fileInput: HTMLInputElement,
     *  source: HTMLTextAreaElement,
     *  historyList: HTMLDivElement,
     *  btnLoad: HTMLButtonElement,
     *  btnClear: HTMLButtonElement,
     *  btnPaste: HTMLButtonElement,
     *  btnView: HTMLButtonElement,
     *  btnClearHistory: HTMLButtonElement,
     *  btnExportHistory: HTMLButtonElement,
     *  btnImportHistory: HTMLButtonElement,
     *  importHistoryInput: HTMLInputElement,
     * }} */
    const el = {
      fileInput: /** @type {HTMLInputElement} */ (document.getElementById('fileInput')),
      source: /** @type {HTMLTextAreaElement} */ (document.getElementById('sourceArea')),
      historyList: /** @type {HTMLDivElement} */ (document.getElementById('historyList')),
      btnLoad: /** @type {HTMLButtonElement} */ (document.getElementById('loadButton')),
      btnClear: /** @type {HTMLButtonElement} */ (document.getElementById('clearButton')),
      btnPaste: /** @type {HTMLButtonElement} */ (document.getElementById('pasteButton')),
      btnView: /** @type {HTMLButtonElement} */ (document.getElementById('viewButton')),
      btnClearHistory: /** @type {HTMLButtonElement} */ (document.getElementById('clearHistoryButton')),
      btnExportHistory: /** @type {HTMLButtonElement} */ (document.getElementById('exportHistoryButton')),
      btnImportHistory: /** @type {HTMLButtonElement} */ (document.getElementById('importHistoryButton')),
      importHistoryInput: /** @type {HTMLInputElement} */ (document.getElementById('importHistoryInput')),
    };

    if (!el.fileInput || !el.source || !el.historyList || !el.btnLoad || !el.btnClear || !el.btnPaste || !el.btnView || !el.btnClearHistory) {
      console.error('One or more elements not found');
    }

    // Config
    // No history limit
    const PREVIEW_CHARS = 80;

    // IndexedDB config
    const DB = {
      name: 'previewer',
      version: 2,
      store: 'entries',
      storeState: 'app_state',
      indexByTime: 'by_time'
    };
    /** @type {Map<number, string>} */
    const historyContentById = new Map();

    /** @returns {Promise<IDBDatabase|null>} */
    function openDatabase() {
      if (!('indexedDB' in window)) return Promise.resolve(null);
      return new Promise(/** @type {any} */(resolve, reject) => {
        const req = indexedDB.open(DB.name, DB.version);
        req.onupgradeneeded = () => {
          const db = req.result;
          if (!db.objectStoreNames.contains(DB.store)) {
            const store = db.createObjectStore(DB.store, { keyPath: 'id', autoIncrement: true });
            store.createIndex(DB.indexByTime, 'ts');
          }
          if (!db.objectStoreNames.contains(DB.storeState)) {
            db.createObjectStore(DB.storeState, { keyPath: 'key' });
          }
        };
        req.onsuccess = (e) => {
          const target = /** @type {IDBOpenDBRequest} */ (e.target);
          if (target) resolve(target.result);
        };
        req.onerror = () => reject(req.error);
      });
    }

    /** 
     * @param {string} htmlContent 
     * @param {string|null} [note]
     * @param {number|null} [ts]
     */
    async function saveHistoryEntry(htmlContent, note = null, ts = null) {
      const trimmed = (htmlContent || '').trim();
      if (!trimmed) return;
      const db = await openDatabase();
      if (!db) return;

      // Check for duplicate of latest entry
      const isDuplicate = await new Promise((resolve) => {
        const tx = db.transaction(DB.store, 'readonly');
        const index = tx.objectStore(DB.store).index(DB.indexByTime);
        const req = index.openCursor(null, 'prev'); // Get latest
        req.onsuccess = (e) => {
          const target = /** @type {IDBRequest<IDBCursorWithValue | null>} */ (e.target);
          if (!target) { resolve(false); return; }
          const cursor = target.result;
          // Duplicate if content matches AND note matches (or both are null/undefined)
          if (cursor && cursor.value.content === trimmed) {
            const currentNote = cursor.value.note || null;
            const newNote = note || null;
            if (currentNote === newNote) {
              resolve(true);
              return;
            }
          }
          resolve(false);
        };
        req.onerror = () => resolve(false);
      });

      if (isDuplicate) return;

      return new Promise(/** @type {any} */(resolve, reject) => {
        const tx = db.transaction(DB.store, 'readwrite');
        tx.oncomplete = () => resolve(undefined);
        tx.onerror = () => reject(tx.error);
        const entry = { content: trimmed, ts: ts || Date.now() };
        if (note) entry.note = note;
        tx.objectStore(DB.store).add(entry);
      });
    }

    /** 
     * @param {number} id 
     * @param {{ name?: string }} updates 
     */
    /** 
     * @param {number} id 
     * @param {string} note 
     */
    async function updateHistoryNote(id, note) {
      const db = await openDatabase();
      if (!db) return;
      return new Promise(/** @type {any} */(resolve, reject) => {
        const tx = db.transaction(DB.store, 'readwrite');
        const store = tx.objectStore(DB.store);
        const req = store.get(id);
        req.onsuccess = () => {
          const data = req.result;
          if (!data) { resolve(undefined); return; }
          // Apply updates
          data.note = note;
          store.put(data);
        };
        tx.oncomplete = () => resolve(undefined);
        tx.onerror = () => reject(tx.error);
      });
    }

    /** @returns {Promise<HistoryEntry[]>} */
    async function fetchHistoryEntries() {
      const db = await openDatabase();
      if (!db) return [];
      return new Promise(/** @type {any} */(resolve, reject) => {
        const tx = db.transaction(DB.store, 'readonly');
        const index = tx.objectStore(DB.store).index(DB.indexByTime);
        const items = [];
        // Get all items, sorted by time descending
        index.openCursor(null, 'prev').onsuccess = (e) => {
          const cursor = e.target.result;
          if (cursor) {
            items.push(cursor.value);
            cursor.continue();
          } else {
            resolve(items);
          }
        };
        tx.onerror = () => reject(tx.error);
      });
    }

    /** @param {number} id */
    async function removeHistoryEntry(id) {
      const db = await openDatabase();
      if (!db) return;
      return new Promise(/** @type {any} */(resolve, reject) => {
        const tx = db.transaction(DB.store, 'readwrite');
        tx.oncomplete = () => resolve(undefined);
        tx.onerror = () => reject(tx.error);
        tx.objectStore(DB.store).delete(id);
      });
    }

    async function exportHistory() {
      const entries = await fetchHistoryEntries();
      if (!entries.length) {
        alert('No history to export.');
        return;
      }
      const data = JSON.stringify(entries, null, 2);
      const blob = new Blob([data], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `previewer_history_${Date.now()}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function importHistory() {
      el.importHistoryInput.click();
    }

    async function clearAllHistory() {
      const db = await openDatabase();
      if (!db) return;
      return new Promise(/** @type {any} */(resolve, reject) => {
        const tx = db.transaction(DB.store, 'readwrite');
        tx.oncomplete = () => resolve(undefined);
        tx.onerror = () => reject(tx.error);
        tx.objectStore(DB.store).clear();
      });
    }

    // --- Autosave / Drafts ---

    /** @param {string} content */
    async function saveDraft(content) {
      const db = await openDatabase();
      if (!db) return;
      return new Promise(/** @type {any} */(resolve, reject) => {
        const tx = db.transaction(DB.storeState, 'readwrite');
        tx.oncomplete = () => resolve(undefined);
        tx.onerror = () => reject(tx.error);
        tx.objectStore(DB.storeState).put({ key: 'draft', content });
      });
    }

    async function loadDraft() {
      const db = await openDatabase();
      if (!db) return '';
      return new Promise(/** @type {any} */(resolve, reject) => {
        const tx = db.transaction(DB.storeState, 'readonly');
        const req = tx.objectStore(DB.storeState).get('draft');
        req.onsuccess = () => resolve(req.result ? req.result.content : '');
        req.onerror = () => reject(req.error);
      });
    }

    // --- Theme Handling ---
    const THEMES = [
      '#000000', // Black
      '#FF1493', // Deep Pink
      '#0000FF', // Blue
      '#FF4500', // Orange Red
      '#008080', // Teal
      '#8A2BE2', // Blue Violet
      '#FFD700', // Gold
      '#32CD32', // Lime Green
      '#DC143C', // Crimson
      '#4B0082', // Indigo
      '#00CED1', // Dark Turquoise
      '#FF00FF', // Magenta
      '#800000', // Maroon
      '#2F4F4F', // Dark Slate Gray
      '#FF8C00', // Dark Orange
    ];

    function getContrastColor(hexcolor) {
      // If a leading # is provided, remove it
      if (hexcolor.slice(0, 1) === '#') {
        hexcolor = hexcolor.slice(1);
      }
      // Convert to RGB value
      var r = parseInt(hexcolor.substr(0, 2), 16);
      var g = parseInt(hexcolor.substr(2, 2), 16);
      var b = parseInt(hexcolor.substr(4, 2), 16);
      // Get YIQ ratio
      var yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
      // Check contrast
      return (yiq >= 128) ? 'black' : 'white';
    }

    function applyTheme(color) {
      document.documentElement.style.setProperty('--accent-color', color);
      document.documentElement.style.setProperty('--on-accent-color', getContrastColor(color));

      // Calculate RGB for transparency
      const r = parseInt(color.slice(1, 3), 16);
      const g = parseInt(color.slice(3, 5), 16);
      const b = parseInt(color.slice(5, 7), 16);
      document.documentElement.style.setProperty('--accent-color-rgb', `${r}, ${g}, ${b}`);

      // Calculate Danger Color (Mix with Red)
      // Mix 50% theme, 50% red (#ff0000)
      const dr = Math.round((r + 255) / 2);
      const dg = Math.round(g / 2);
      const db = Math.round(b / 2);
      document.documentElement.style.setProperty('--danger-color', `rgb(${dr}, ${dg}, ${db})`);

      const indicator = document.getElementById('currentThemeIndicator');
      if (indicator) indicator.style.backgroundColor = color;
    }

    async function saveTheme(color) {
      const db = await openDatabase();
      if (!db) return;
      return new Promise(/** @type {any} */(resolve, reject) => {
        const tx = db.transaction(DB.storeState, 'readwrite');
        tx.oncomplete = () => resolve(undefined);
        tx.onerror = () => reject(tx.error);
        tx.objectStore(DB.storeState).put({ key: 'theme', color });
      });
    }

    let savedTheme = THEMES[0]; // Default

    function initThemePicker() {
      const dropdown = document.getElementById('themeDropdown');
      const picker = document.querySelector('.theme-picker');
      if (!dropdown || !picker) return;

      // Clear existing options to prevent duplicates if called multiple times
      dropdown.innerHTML = '';

      THEMES.forEach(color => {
        const option = document.createElement('div');
        option.className = 'theme-option';
        option.style.backgroundColor = color;
        option.title = color;

        // Click to save and apply
        option.addEventListener('click', () => {
          savedTheme = color;
          applyTheme(color);
          saveTheme(color);
        });

        // Hover to preview
        option.addEventListener('mouseenter', () => {
          applyTheme(color);
        });

        dropdown.appendChild(option);
      });

      // Revert on mouse leave
      picker.addEventListener('mouseleave', () => {
        applyTheme(savedTheme);
      });
    }

    async function loadTheme() {
      const db = await openDatabase();
      if (!db) return;
      return new Promise((resolve) => {
        const tx = db.transaction(DB.storeState, 'readonly');
        const req = tx.objectStore(DB.storeState).get('theme');
        req.onsuccess = () => {
          if (req.result && req.result.color) {
            savedTheme = req.result.color;
            applyTheme(savedTheme);
          }
          resolve(undefined);
        };
        req.onerror = () => resolve(undefined);
      });
    }/** @returns {Promise<void>} */
    async function renderHistoryList() {
      const listEl = el.historyList;
      if (!listEl) return;
      const entries = await fetchHistoryEntries();
      historyContentById.clear();
      listEl.innerHTML = '';
      if (entries.length === 0) {
        el.historyList.innerHTML = '<div class="empty-history" style="color: var(--accent-color); opacity: 0.5; text-align: left; padding: 1rem 0; font-size: 0.9rem; font-weight: 300; text-transform: uppercase;">No history yet.</div>';
        return;
      }
      const frag = document.createDocumentFragment();
      for (const entry of entries) {
        if (entry.id === undefined) continue;
        historyContentById.set(entry.id, entry.content);
        const row = document.createElement('div');
        row.className = 'history-item';
        row.dataset.id = String(entry.id);

        const info = document.createElement('div');
        info.className = 'history-info';

        const meta = document.createElement('span');
        meta.className = 'history-meta';
        meta.textContent = formatTimestamp(entry.ts);

        const previewText = (entry.content || '').replace(/\s+/g, ' ').slice(0, PREVIEW_CHARS);

        const mainLabel = document.createElement('strong');
        mainLabel.style.display = 'block';
        mainLabel.textContent = entry.note || previewText;

        const subLabel = document.createElement('div');
        subLabel.style.fontSize = '0.85em';
        subLabel.style.opacity = '0.7';
        subLabel.textContent = entry.note ? previewText : '';

        info.appendChild(meta);
        info.appendChild(mainLabel);
        if (entry.note) info.appendChild(subLabel);

        const actions = document.createElement('div');
        actions.className = 'history-actions';

        const viewBtn = document.createElement('button');
        viewBtn.className = 'btn-icon';
        viewBtn.textContent = 'VIEW';
        viewBtn.dataset.action = 'view';

        const noteBtn = document.createElement('button');
        noteBtn.className = 'btn-icon';
        noteBtn.textContent = 'NOTE';
        noteBtn.dataset.action = 'note';
        // Store current note in dataset for easy access
        if (entry.note) noteBtn.dataset.currentNote = entry.note;

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'btn-icon danger';
        deleteBtn.textContent = 'DELETE';
        deleteBtn.dataset.action = 'delete';

        actions.appendChild(viewBtn);
        actions.appendChild(noteBtn);
        actions.appendChild(deleteBtn);
        row.appendChild(info);
        row.appendChild(actions);
        frag.appendChild(row);
      }
      listEl.appendChild(frag);
    }

    /** @param {number} ts */
    function formatTimestamp(ts) {
      try { return new Date(ts).toLocaleString(); }
      catch { return String(ts); }
    }

    /** @param {string} htmlContent */
    function openHtmlInNewTab(htmlContent) {
      const blob = new Blob([htmlContent], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      window.open(url, '_blank');
    }

    function setupStickyToolbar() {
      const toolbar = document.getElementById('toolbar');
      if (!toolbar) return;

      const observer = new IntersectionObserver(
        ([e]) => e.target.classList.toggle('is-stuck', e.intersectionRatio < 1),
        { threshold: [1] }
      );

      // We need a sentinel to detect when sticky is active
      // But for simplicity with top:0, we can just check scroll
      window.addEventListener('scroll', () => {
        toolbar.classList.toggle('is-stuck', window.scrollY > 10);
      });
    }

    function attachEventHandlers() {
      el.btnLoad.addEventListener('click', () => el.fileInput.click());

      el.fileInput.addEventListener('change', (evt) => {
        /** @type {FileList | null} */
        const files = (evt.target && /** @type {HTMLInputElement} */(evt.target)).files;
        const file = files && files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
          const target = /** @type {FileReader} */ (e.target);
          const content = String((target && target.result) || '');
          if (el.source) {
            el.source.value = content;
            saveDraft(content);
          }
        };
        reader.readAsText(file);
      });

      el.btnClear.addEventListener('click', () => {
        el.source.value = '';
        saveDraft('');
      });

      el.btnPaste.addEventListener('click', () => {
        navigator.clipboard.readText().then((text) => {
          if (!text.trim()) { alert('Clipboard is empty or contains no text.'); return; }
          el.source.value = text;
          saveDraft(text);
        }).catch((err) => {
          console.error('Failed to read clipboard:', err);
          alert('Failed to read clipboard. Check permissions.');
        });
      });

      el.btnView.addEventListener('click', () => {
        const htmlContent = el.source.value;
        if (!htmlContent.trim()) { alert('No HTML content found.'); return; }
        openHtmlInNewTab(htmlContent);
        saveHistoryEntry(htmlContent).then(renderHistoryList).catch(() => { });
      });

      el.historyList.addEventListener('click', async (evt) => {
        const target = /** @type {HTMLElement} */ (evt.target);
        const btn = target.closest('button');
        if (!btn) return;
        const row = btn.closest('.history-item');
        if (!row || !(row instanceof HTMLElement)) return;
        const id = Number(row.dataset.id);
        const action = btn.dataset.action;
        if (action === 'view') {
          const htmlContent = historyContentById.get(id);
          if (htmlContent) openHtmlInNewTab(htmlContent);
        } else if (action === 'delete') {
          await removeHistoryEntry(id);
          await renderHistoryList();
        } else if (action === 'note') {
          const currentNote = btn.dataset.currentNote || '';
          const newNote = prompt('Enter note:', currentNote);
          if (newNote !== null) {
            await updateHistoryNote(id, newNote);
            await renderHistoryList();
          }
        }
      });

      el.btnClearHistory.addEventListener('click', () => {
        clearAllHistory().then(renderHistoryList);
      });

      el.btnExportHistory.addEventListener('click', exportHistory);
      el.btnImportHistory.addEventListener('click', importHistory);

      el.importHistoryInput.addEventListener('change', (evt) => {
        const files = (evt.target && /** @type {HTMLInputElement} */(evt.target)).files;
        const file = files && files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = async (e) => {
          try {
            const target = /** @type {FileReader} */ (e.target);
            const content = String((target && target.result) || '');
            const entries = JSON.parse(content);
            if (!Array.isArray(entries)) throw new Error('Invalid format');

            let count = 0;
            for (const entry of entries) {
              if (entry.content) {
                // Handle legacy 'name' field if present
                const note = entry.note || entry.name || null;
                await saveHistoryEntry(entry.content, note, entry.ts);
                count++;
              }
            }
            alert(`Imported ${count} entries.`);
            renderHistoryList();
          } catch (err) {
            console.error(err);
            alert('Failed to import history. Invalid JSON file.');
          }
          el.importHistoryInput.value = ''; // Reset
        };
        reader.readAsText(file);
      });

      // Autosave on input
      el.source.addEventListener('input', () => {
        saveDraft(el.source.value);
      });
    }

    function init() {
      attachEventHandlers();
      setupStickyToolbar();
      initThemePicker();

      // Load draft
      loadDraft().then(draft => {
        if (draft && el.source) el.source.value = draft;
      });

      // Load theme
      loadTheme().then(color => {
        if (color) applyTheme(color);
      });

      renderHistoryList();
    }

    init();
  </script>
</body>

</html>